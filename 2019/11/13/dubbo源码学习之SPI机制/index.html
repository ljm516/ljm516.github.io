<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>dubbo源码学习之SPI机制 | ljming的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文记录源码学习dubbo spi扩展机制笔记。">
<meta name="keywords" content="dubbo">
<meta property="og:type" content="article">
<meta property="og:title" content="dubbo源码学习之SPI机制">
<meta property="og:url" content="https://ljm516.github.io/2019/11/13/dubbo源码学习之SPI机制/index.html">
<meta property="og:site_name" content="ljming的博客">
<meta property="og:description" content="本文记录源码学习dubbo spi扩展机制笔记。">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://ljm516.github.io/2019/11/13/dubbo源码学习之SPI机制/dubbo-spi改进.jpg">
<meta property="og:image" content="https://ljm516.github.io/2019/11/13/dubbo源码学习之SPI机制/spi配置规范.jpg">
<meta property="og:updated_time" content="2019-11-18T16:38:05.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dubbo源码学习之SPI机制">
<meta name="twitter:description" content="本文记录源码学习dubbo spi扩展机制笔记。">
<meta name="twitter:image" content="https://ljm516.github.io/2019/11/13/dubbo源码学习之SPI机制/dubbo-spi改进.jpg">
  
    <link rel="alternate" href="/atom.xml" title="ljming的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ljming的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">程序人生</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ljm516.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-dubbo源码学习之SPI机制" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/13/dubbo源码学习之SPI机制/" class="article-date">
  <time datetime="2019-11-13T13:13:27.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      dubbo源码学习之SPI机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文记录源码学习dubbo spi扩展机制笔记。</p>
<a id="more"></a>
<p>SPI 是Service Provider Interface的缩写，Java SPI 使用了策略模式，一个接口多种实现。与Java SPI相比，Dubbo SPI做了一定的改进和优化，官方文档是这么说的:<br><img src="/2019/11/13/dubbo源码学习之SPI机制/dubbo-spi改进.jpg" alt="dubbo spi的改进及优化"></p>
<h2 id="扩展点的配置规范"><a href="#扩展点的配置规范" class="headerlink" title="扩展点的配置规范"></a>扩展点的配置规范</h2><p>dubbo spi 需要在 <code>META-INF/dubbo/</code>下放置对应的SPI配置文件，文件名需要命名为接口的全路径名。配置文件的内容为key=扩展点实现类全路径名，如有多个，使用换行符分割。key会作为dubbo spi注解中的传入参数。dubbo spi也兼容了java spi的配置路径和内容配置方式。在dubbo启动时，会默认扫描<code>META-INF/services/</code>,<code>META-INF/dubbo/</code>,<code>META-INF/dubbo/internal/</code>这三个目录的配置文件。<br><img src="/2019/11/13/dubbo源码学习之SPI机制/spi配置规范.jpg" alt="spi配置规范"></p>
<h2 id="扩展点的特性"><a href="#扩展点的特性" class="headerlink" title="扩展点的特性"></a>扩展点的特性</h2><p>扩展类一共包含四种特性: 自动包装、自动加载、自适应和自动激活。</p>
<h3 id="自动包装"><a href="#自动包装" class="headerlink" title="自动包装"></a>自动包装</h3><p>自动包装是一种被缓存的扩展类，ExtensionLoader在加载扩展时，如果发现这个扩展类包含其它扩展点作为构造函数的参数，则这个扩展类就会被认为是Wrapper类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">    <span class="comment">// 实现了Protocol，但构造函数中又传了一个Protocol类型参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProtocolFilterWrapper类虽然实现了Protocol接口，但是其构造函数中又注入了一个Protocol的参数，这样ProtocolFilterWrapper就会被认定为是Wrapper类。这是一种装饰器模式，把通用的抽象逻辑进行封装或对子类进行增强，让子类可以更加专注具体的实现。</p>
<h3 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h3><p>如果某个扩展类是另外一个扩展点类的成员属性，并且拥有setter方法，那么框架也会自动注入对应的扩展点实例。ExtensionLoader在执行扩展点初始化时，会自动通过setter方法注入对应的实现类。那如果扩展类属性是一个接口 ，它有多种实现，具体注入又是那个？这就涉及第三个特性—自适应。</p>
<h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><p>在dubbo spi中，使用@Adaptive注解，可以动态地通过URL中的参数来确定使用哪个具体的实现类。从而解决自动加载中的实例注入问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述类的功能.</span></span><br><span class="line"><span class="comment"> * SPI注解，有一个value属性，通过传入这个值，设置该接口的默认实现类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lijm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(value = <span class="string">"dog"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果Adaptive注解中没有key参数，</span></span><br><span class="line"><span class="comment">     * 则默认会把类名转换成key，Animal类就会转化成animal。</span></span><br><span class="line"><span class="comment">     * 如果url参数中没有animal这个参数，则会取默认值，也就是spi的默认实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(value = &#123;<span class="string">"name"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url, String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@Adaptive注解的value属性是一个数组类型，可以接收多个参数，@Adaptive注解会依次取value值去匹配，如果能匹配上某个扩展实现类则直接使用对应的实现类。如果都不匹配则抛出异常。<br>这种动态寻找实现类的方式比较灵活，但是只能激活一个具体实现类，如果需要多个同时激活呢（根据条件不同，同时激活多个实现类）？这就涉及最后一个特性—自动激活。</p>
<h3 id="自动激活"><a href="#自动激活" class="headerlink" title="自动激活"></a>自动激活</h3><p>使用@Activate注解，可以标记对应的扩展点默认被激活启用。该注解还可以传入不同的参数，设置扩展点在不同的条件下被自动激活。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(value = <span class="string">"dog"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以标记在类，接口，枚举类和方法上。主要使用在有多个扩展点实现、需要根据不同条件被激活的场景中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Activate</span>(group = <span class="string">"default"</span>, value = &#123;<span class="string">"dogImp"</span>, <span class="string">"sheepImpl"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testActivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">    Map&lt;String, String&gt; keyPair = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    keyPair.put(<span class="string">"dogImpl"</span>, <span class="string">"dog"</span>);</span><br><span class="line">    keyPair.put(<span class="string">"sheepImpl"</span>, <span class="string">"sheep"</span>);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"dobbo"</span>, <span class="string">"localhost"</span>, <span class="number">1111</span>, keyPair);</span><br><span class="line">    <span class="comment">// 根据条件激活</span></span><br><span class="line">    List&lt;Animal&gt; animalList = extensionLoader.getActivateExtension(url, <span class="string">"dogImpl"</span>, <span class="string">"default"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Animal animal : animalList) &#123;</span><br><span class="line">        animal.eat(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展点相关注解"><a href="#扩展点相关注解" class="headerlink" title="扩展点相关注解"></a>扩展点相关注解</h2><h3 id="SPI注解"><a href="#SPI注解" class="headerlink" title="@SPI注解"></a>@SPI注解</h3><p>该注解可以用在类、接口和枚举类上，dubbo都是用在接口上。主要用来标记这个接口是一个dubbo spi接口，不同的内置或用户有不同的定义实现，运行时需要通过配置找到具体的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * default extension name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@SPI注解只有一个value属性，通过这个属性，可以传入不同的参数来设置这个接口的默认实现。<br>例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述类的功能.</span></span><br><span class="line"><span class="comment"> * SPI注解，有一个value属性，通过传入这个值，设置该接口的默认实现类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lijm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(value = <span class="string">"dog"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test for get spi default</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展点注解测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SPI</span>注解，可以通过传入value参数，设置接口的默认实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Animal&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">    Animal animal = extensionLoader.getDefaultExtension(); <span class="comment">// 通过这个方法获取默认实现</span></span><br><span class="line">    animal.talk(); <span class="comment">// 这里应该是dog，因为Animal类的默认扩展实现类是Dog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定一个Animal接口，通过@SPI注解，传入dog表示Dog类这个接口的默认实现类。</p>
<h3 id="Adaptive注解"><a href="#Adaptive注解" class="headerlink" title="@Adaptive注解"></a>@Adaptive注解</h3><p>该注解可以定义在类、接口、枚举类和方法上，如果定义在接口的方法上，则可以通过参数动态获得实现类（自适应特性）。方法级别注解在第一个getExtension时，会自动生成和编译一个动态的Adaptive类，从而达到动态实现类的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的自适应特性的地方已经给出了例子，这里不重复。在扩展点接口的多个实现里，只能有一个实现上可以加@Adaptive注解，如果多个实现类都有该注解，则会抛出异常<code>More than 1 adptive calss found</code>。从@Adaptive注解的代码知道，也传入一个value传输，value参数是一个数组，可以传入多个值，对传入的URL进行key匹配，如果第一个没匹配上，就匹配第二个，如果都没匹配上，则使用@SPI注解中的默认实现。如果@SPI也没默认值，则抛出IllegalStateException。</p>
<h3 id="Activate注解"><a href="#Activate注解" class="headerlink" title="@Activate注解"></a>@Activate注解</h3><p>该注解使用在类、接口、枚举和方法上。主要使用在有个扩展点实现、需要根据不同条件被激活的场景中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// URL中的分组如果匹配则激活，可以配置多个</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 查找URL中如果含有该key值，则会激活</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 填写扩展点列表，表示哪些扩展点要在本扩展点之前（已废弃）</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 同上，表示哪些需要在本扩展点之后（已废弃）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// 直接的排序信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自动激活特性中给出了获取自动激活实现的例子，不在重复。</p>
<h2 id="ExtensionLoader原理"><a href="#ExtensionLoader原理" class="headerlink" title="ExtensionLoader原理"></a>ExtensionLoader原理</h2><p>ExtensionLoader是整个扩展机制的主要逻辑类，在这个类里面实现了配置的加载、扩展类缓存、自适应对象生成等所有工作。ExtensionLoader的逻辑入口分为getExtension、getAdaptiveExtension和getActivateExtension三个，分别是获取普通扩展类、获取自适应扩展类、获取自动激活的扩展类。</p>
<h3 id="getExtension的实现原理"><a href="#getExtension的实现原理" class="headerlink" title="getExtension的实现原理"></a>getExtension的实现原理</h3><p>下面将从getExtension方法为入口，跟着方法调用栈逐步分析一下几个方法：</p>
<ul>
<li>getExtension(String name)</li>
<li>createExtension(String name)</li>
<li>getExtensionClasses()</li>
<li>loadExtensionClasses()</li>
<li>loadDirectory(Map<string, class<?="">&gt; extensionClasses, String dir, String type)</string,></li>
<li>loadResource(Map<string, class<?="">&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</string,></li>
<li>loadClass(Map<string, class<?="">&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</string,></li>
</ul>
<p>这几个方法的实现一起组合成getExtension方法实现原理，也是接下来创建自适应扩展类和自动激活扩展类的数据基础。</p>
<h4 id="源码分析getExtension-String-name-方法"><a href="#源码分析getExtension-String-name-方法" class="headerlink" title="源码分析getExtension(String name)方法"></a>源码分析getExtension(String name)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的name参数，找到扩展类，如果找不到则抛出IllegalStateException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123; <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name); <span class="comment">// ②</span></span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name); <span class="comment">// ③</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①中如果name是true，则表示去默认扩展类；②获取扩展类的holder，Holder类持有扩展类的实例，获取Holder的逻辑是先从缓存中通过name获取，如果没有获取到就new一个；③获取扩展类的实例，是先从第二步中获取的Holer类中尝试获取扩展类实例，如果没有获取到，则通过createExtension方法创建实例。</p>
<h4 id="源码分析createExtension-String-name-方法"><a href="#源码分析createExtension-String-name-方法" class="headerlink" title="源码分析createExtension(String name)方法"></a>源码分析createExtension(String name)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz); <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance); <span class="comment">// ③</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; <span class="comment">// ④</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance (name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">") couldn't be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①中从缓存中通过name获取实例的clazz，如果获取不到，抛出异常；②中通过class从缓存个中获取实例，如果没有获取到，通过反射的方式创建实例；③向扩展类注入其它依赖的属性，如果扩展A又依赖了扩展类B。④遍历所有的扩展点包装类，用于初始化包装类实例，然后找到构造函数为type(也就是扩展类的类型)的包装类，为期注入扩展类实例。(cachedWrapperClasses)的来源在getExtensionClasses()方法。</p>
<h4 id="源码分析getExtensionClasses-方法"><a href="#源码分析getExtensionClasses-方法" class="headerlink" title="源码分析getExtensionClasses()方法"></a>源码分析getExtensionClasses()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法逻辑也是先从缓存中获取扩展类，如果缓存没有获取，这通过loadExtensionClasses()方法加载，所以现在可以看出，获取扩展类的核心就在loadExtensionClasses()方法。</p>
<h4 id="源码分析loadExtensionClasses-方法"><a href="#源码分析loadExtensionClasses-方法" class="headerlink" title="源码分析loadExtensionClasses()方法"></a>源码分析loadExtensionClasses()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    cacheDefaultExtensionName(); <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①中主要是默认扩展类的加载逻辑，通过扫描@SPI注解，获取@SPI注解的value值，作为默认扩展的key。如果存在多个默认实现则抛出异常。②则为加载扩展类配置文件，主要扫描<code>META-INF/dubbo/interanl/</code>,<code>META-INF/dubbo/</code>,<code>META-INF/services/</code>这个是那个文件夹。</p>
<h4 id="源码分析loadDirectory-Map"><a href="#源码分析loadDirectory-Map" class="headerlink" title="源码分析loadDirectory(Map"></a>源码分析loadDirectory(Map<string, class<?="">&gt; extensionClasses, String dir, tring type)方法</string,></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type)</span> </span>&#123;</span><br><span class="line">    String fileName = dir + type; <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        ClassLoader classLoader = findClassLoader(); <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName); <span class="comment">// ③</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL); <span class="comment">// ④</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception occurred when loading extension class (interface: "</span> +</span><br><span class="line">                type + <span class="string">", description file: "</span> + fileName + <span class="string">")."</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①构建文件名，文件的命名方式为类的全限定名；②获取类加载器；③urls中存放的文件里配置的可选可扩展类，通过classLoader加载classes文件目录下的扩展类配置文件（打包后的路径）的路径，然后放入urls中；④通过loadResource方法加载扩展类。</p>
<h4 id="源码分析loadResource-Map"><a href="#源码分析loadResource-Map" class="headerlink" title="源码分析loadResource(Map"></a>源码分析loadResource(Map<string, class<?="">&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) 方法</string,></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123; <span class="comment">// ①</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// ②</span></span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim(); <span class="comment">//这就是配置的key</span></span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim(); <span class="comment">//这是扩展类的全限定名</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name); <span class="comment">//③</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       <span class="comment">// handle Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// handle Exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①根据扩展类配置文件路径，创建BufferedReader，循环读取每一行；②解析出扩展类的key和类全限名，通过<code>=</code>分割；③然后执行loadClass方法。</p>
<h4 id="源码分析loadClass-Map"><a href="#源码分析loadClass-Map" class="headerlink" title="源码分析loadClass(Map"></a>源码分析loadClass(Map<string, class<?="">&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)方法</string,></h4><p>在调用该方法之前，会先通过Class.forName方法得到扩展类的clazz。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error occurred when loading extension class (interface: "</span> +</span><br><span class="line">                type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                + clazz.getName() + <span class="string">" is not subtype of interface."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123; <span class="comment">// ①</span></span><br><span class="line">        cacheAdaptiveClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123; <span class="comment">// ②</span></span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            name = findAnnotationName(clazz); <span class="comment">// ③</span></span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]); <span class="comment">// ④</span></span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                cacheName(clazz, n);  <span class="comment">// ⑤</span></span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n); <span class="comment">// ⑥</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①判断当前扩展类是否为自适应扩展类，如果是将clazz复制给cachedAdaptiveClass。②判断当前扩展类是否为包装类，判断依据就是看当前类是否有一个public的参数为要实现扩展的接口的构造函数。如果是包装类，将clazz添加到cachedWrapperClasses（set集合）。③如果传过来的name参数（扩展类配置文件的key）为空，则通过findAnnotationName方法获取name，如果还是获取不到，则抛出异常，提示找不到扩展名。④将clazz和name的信息存入cachedActivates（map），key=name，value=@Activite注解；⑤保存class和name的信息到cachedNames（map），key=clazz，value=name；⑥将clazz放入extensionClasses（map），key=name, value=clazz。</p>
<h4 id="getExtension实现小结"><a href="#getExtension实现小结" class="headerlink" title="getExtension实现小结"></a>getExtension实现小结</h4><p>从上述分析，主要是通过getExtensionClasses方法获取所有的可扩展类，具体需要的那个扩展类就通过name参数获取。在getExtensionClasses方法中，会将扩展类需要的自适应扩展类和自动激活扩展类缓存起来，用于后续使用。需要提一下的是:扩展类实例被创建后，会放入EXTENSION_INSTANCES（map），key=clazz，value=类实例。自适应扩展类缓存cachedAdaptiveClass，自适应扩展类只能有一个。自动激活扩展类缓存为cachedActivates（map），key=扩展类配置文件的key，value=@Activate。包装类缓存在cachedWrapperClasses（set），存储的是扩展类的clazz。</p>
<h3 id="getAdaptiveExtension的实现原理"><a href="#getAdaptiveExtension的实现原理" class="headerlink" title="getAdaptiveExtension的实现原理"></a>getAdaptiveExtension的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object instance = cachedAdaptiveInstance.get(); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = createAdaptiveExtension(); <span class="comment">// ②</span></span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="comment">// handle exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①获取缓存获取，如果没有去创建。②创建自适应扩展类。</p>
<h4 id="源码分析createAdaptiveExtension-方法"><a href="#源码分析createAdaptiveExtension-方法" class="headerlink" title="源码分析createAdaptiveExtension()方法"></a>源码分析createAdaptiveExtension()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private T createAdaptiveExtension() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Can&apos;t create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要还是调用getAdaptiveExtensionClass方法，获取扩展类clazz，然后通过反射创建类实例。然后执行injectExtension方法，为其注入引入的其它扩展类。下面看下getAdaptiveExtensionClass的实现。</p>
<h4 id="源码分析getAdaptiveExtensionClass-方法"><a href="#源码分析getAdaptiveExtensionClass-方法" class="headerlink" title="源码分析getAdaptiveExtensionClass()方法"></a>源码分析getAdaptiveExtensionClass()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses(); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass(); <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①首先执行getExtensionClasses()方法，确定扩展类都被加载了。cachedAdaptiveClass是创建扩展附加产物，如果扩展类没有指定自适应扩展类，则通过②来获取自适应扩展类。</p>
<h4 id="源码分析createAdaptiveExtensionClass-方法"><a href="#源码分析createAdaptiveExtensionClass-方法" class="headerlink" title="源码分析createAdaptiveExtensionClass()方法"></a>源码分析createAdaptiveExtensionClass()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate(); </span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的逻辑就是根据默认的扩展类实现，默认的扩展类实现是@SPI注解的value，然后生成默认扩展类的类文件代码，通过编译器编译生成类。</p>
<h3 id="getActivateExtension的实现原理"><a href="#getActivateExtension的实现原理" class="headerlink" title="getActivateExtension的实现原理"></a>getActivateExtension的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">    <span class="keyword">if</span> (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Object activate = entry.getValue();</span><br><span class="line"></span><br><span class="line">            String[] activateGroup, activateValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> Activate) &#123;</span><br><span class="line">                activateGroup = ((Activate) activate).group();</span><br><span class="line">                activateValue = ((Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> com.alibaba.dubbo.common.extension.Activate) &#123;</span><br><span class="line">                activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();</span><br><span class="line">                activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activateGroup)) &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">                        &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                        &amp;&amp; isActive(activateValue, url)) &#123;</span><br><span class="line">                    exts.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exts.sort(ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                    exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                    usrs.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                usrs.add(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">        exts.addAll(usrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑为根据传入的value数组(选择的自动激活的扩展类)创建扩展类，value数组是URL中指定的key（多个用逗号隔开）。exts.sort(ActivateComparator.COMPARATOR) 排序是根据@Activate中配置的 before、after、order等参数进行排序的。需要注意的是，如果URL参数中传入了<code>-default</code>，则所有的默认@Activate都不会被激活，只有URL参数中指定的扩展点会被激活。如果传入<code>-</code>符开头的扩展名，则该扩展点不会被激活。</p>
<h3 id="ExtensionFactory的实现原理"><a href="#ExtensionFactory的实现原理" class="headerlink" title="ExtensionFactory的实现原理"></a>ExtensionFactory的实现原理</h3><p>从上面获取扩展类的实现看，ExtensionLoader是整个扩展类实现的核心，那么ExtensionLoader又是怎么创建的呢？<br>首先看ExtensionLoader的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExtensionLoader是通过ExtensionFactory创建的，ExtensionFactory有三个实现类，AdaptiveExtensionFactory、SpiExtensionFactory和SpringExtensionFactory，也就是说dubbo spi管理容器还可以从spring容器中获取。其中AdaptiveExtensionFactory类上加上了@Adaptive注解。</p>
<h4 id="源码分析SpringExtensionFactory的getExtension方法"><a href="#源码分析SpringExtensionFactory的getExtension方法" class="headerlink" title="源码分析SpringExtensionFactory的getExtension方法"></a>源码分析SpringExtensionFactory的getExtension方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SPI should be get from SpiExtensionFactory</span></span><br><span class="line">    <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationContext context : CONTEXTS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.containsBean(name)) &#123;</span><br><span class="line">            Object bean = context.getBean(name);</span><br><span class="line">            <span class="keyword">if</span> (type.isInstance(bean)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (T) bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class == type) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationContext context : CONTEXTS) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException multiBeanExe) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException noBeanExe) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①的逻辑就是遍历所有spring上下文，先根据名字从spring容器中查找；②如果①中根据名字没找到，则直接根据类型查找。</p>
<p>那么Spring的上下文又是在什么时候保存的呢？在ReferenceBean和ServiceBean创建时，会调用静态方法保存spring上下文，即一个服务被发布和被引用的时候，对应的spring上下文被保存下来，这个逻辑在下一遍解析。</p>
<h4 id="源码分析SpiExtensionFactory的getExtension方法"><a href="#源码分析SpiExtensionFactory的getExtension方法" class="headerlink" title="源码分析SpiExtensionFactory的getExtension方法"></a>源码分析SpiExtensionFactory的getExtension方法</h4><p>SpiExtensionFactory主要是获取扩展类接口对应的Adaptive实现类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type); <span class="comment">// ①</span></span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123; <span class="comment">// ②</span></span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>①根据类型获取所有的扩展点加载器；②loader.getSupportedExtension()方法获取缓存的扩展类，如果缓存的扩展类不为空，调用ExtensionLoader的getAdaptiveExtension方法创建扩展类。</p>
<h4 id="源码分析AdaptiveExtensionFactory"><a href="#源码分析AdaptiveExtensionFactory" class="headerlink" title="源码分析AdaptiveExtensionFactory"></a>源码分析AdaptiveExtensionFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123; <span class="comment">// ①</span></span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name); <span class="comment">// ②</span></span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>factories工厂列表，也是通过spi实现的，因此可以在这里获取所有工厂的扩展点加载器。被AdaptiveExtensionFactory 缓存的工厂会通过TreeSet进行排序，SPI排在前面，Spring排在后面。当调用getExtension方法时，优先从SPI容器中获取扩展类，如果没找到，在从spring容器中找。<br>①遍历所有的工厂名称，获取对应的工厂，并保存到factories列表中。②在getExtension的实现中，只是遍历了factories，最终还是调用SPI或者Sping工厂实现的getExtension方法。</p>
<h2 id="扩展点动态编译实现"><a href="#扩展点动态编译实现" class="headerlink" title="扩展点动态编译实现"></a>扩展点动态编译实现</h2><p>dubbo中有三种代码编译器，分别是JDK、Javassist和AdaptiveCompiler这三种编译器。都实现了Compiler接口。Compiler接口上有个@SPI注解，默认值为@SPI(“javassist”)，表示Javassist作为默认编译器器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compile java source code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code        Java source code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader classloader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Compiled class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>&lt;dubbo:application compiler=&quot;jdk&quot;&gt;</code>来指定编译器类型。</p>
<h3 id="源码分析AdaptiveCompiler"><a href="#源码分析AdaptiveCompiler" class="headerlink" title="源码分析AdaptiveCompiler"></a>源码分析AdaptiveCompiler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCompiler</span> <span class="keyword">implements</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> String DEFAULT_COMPILER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultCompiler</span><span class="params">(String compiler)</span> </span>&#123;</span><br><span class="line">        DEFAULT_COMPILER = compiler; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; compile(String code, ClassLoader classLoader) &#123;</span><br><span class="line">        Compiler compiler;</span><br><span class="line">        ExtensionLoader&lt;Compiler&gt; loader = ExtensionLoader.getExtensionLoader(Compiler.class);</span><br><span class="line">        String name = DEFAULT_COMPILER; <span class="comment">// copy reference</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            compiler = loader.getExtension(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compiler = loader.getDefaultExtension();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdaptiveCompiler上有@Adaptive注解，说明AdaptiveCompiler会固定为默认实现，这个compiler的作用和AdaptiveExtensionFactory类型，用来管理其他的compiler。</p>
<p>setDefaultCompiler方法为设置默认的编译器名称。compile方法，先通过ExtensionLoader获取对应的编译器扩展类实现，然后调用真正的compile做编译。</p>
<h2 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a>本文总结</h2><p>本文主要学习了dubbo spi机制，了解了spi的一些概要信息，包括spi的新特性、配置规范、内部缓存等。然后学习了spi最重要的三个注解:@SPI、@Adaptive、@Activate，以及这三个注解的实现原理。然后结合ExtensionLoader类，源码分析了getExtension、getAdaptiveExtension、getActivateExtension这几个重要方法。最后简单了解了ExtensionFactory和自适应机制中的动态编译实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ljm516.github.io/2019/11/13/dubbo源码学习之SPI机制/" data-id="ck42msu59004ulx5sr76pwl9s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dubbo/">dubbo</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/18/dubbo源码学习之服务注册于发现/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          dubbo源码学习之服务注册与发现
        
      </div>
    </a>
  
  
    <a href="/2019/10/28/ReentrantLock和AQS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ReentrantLock和AQS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息队列/">消息队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/经历/">经历</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC/">JUC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java数据结构/">Java数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/broker/">broker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/consumer/">consumer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/producer/">producer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrapy/">scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件处理/">文件处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 18px;">JVM</a> <a href="/tags/Java数据结构/" style="font-size: 12px;">Java数据结构</a> <a href="/tags/MySQL/" style="font-size: 12px;">MySQL</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/RocketMQ/" style="font-size: 16px;">RocketMQ</a> <a href="/tags/Spark/" style="font-size: 14px;">Spark</a> <a href="/tags/broker/" style="font-size: 10px;">broker</a> <a href="/tags/consumer/" style="font-size: 12px;">consumer</a> <a href="/tags/dubbo/" style="font-size: 16px;">dubbo</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/notes/" style="font-size: 10px;">notes</a> <a href="/tags/producer/" style="font-size: 10px;">producer</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/scrapy/" style="font-size: 18px;">scrapy</a> <a href="/tags/多线程/" style="font-size: 18px;">多线程</a> <a href="/tags/文件处理/" style="font-size: 10px;">文件处理</a> <a href="/tags/爬虫/" style="font-size: 20px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 12px;">设计模式</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/23/dubbo源码学习之集群容错机制/">dubbo源码学习之集群容错机制</a>
          </li>
        
          <li>
            <a href="/2019/11/20/dubbo源码学习之服务负载均衡实现/">dubbo源码学习之服务负载均衡实现</a>
          </li>
        
          <li>
            <a href="/2019/11/18/dubbo源码学习之服务注册于发现/">dubbo源码学习之服务注册与发现</a>
          </li>
        
          <li>
            <a href="/2019/11/13/dubbo源码学习之SPI机制/">dubbo源码学习之SPI机制</a>
          </li>
        
          <li>
            <a href="/2019/10/28/ReentrantLock和AQS/">ReentrantLock和AQS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lijianmging<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>