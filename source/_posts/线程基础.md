---
title: 线程基础
date: 2019-10-20 00:52:42
categories: Java
tags:
- 多线程
---
java线程基础知识点。

<!--more    -->
## 线程
在理解线程池之前，先了解线程的相关知识。
### 创建线程
java中创建一个线程很简单，通过以下方式就可以创建一个线程:

```java
Thread t = new Thread();
//但是这样线程t不会做任何事情，启动后立马就结束了(还没开始就结束了)。所以我们要重写它的run方法。
Thread t = new Thread() {
    @Override
    public void run() {
        System.out.println("hello + " + Thread.currentThread().getName());
    }
};
t.start();
```

又或者说可以定义一个类，集成Runable接口，Runable接口只有一个run方法。然后将这个类传入到Thread的构造函数里，这样就可以不用run方法。 

```java
public class Task implements Runnable {
    @Override
    public void run() {
        System.out.println("hello " + Thread.currentThread().getName());
    }
}
Thread t = new Thread(new Task());
```

注意，不用通过调用run()方法开启一个线程，run()方法只是会串行的运行run()方法的逻辑。

### 线程终止
从Thread类的api可以看到，它提供了一个stop()方法来终止当前线程，但是这个方式被标注为废弃。这是因为stop()方法来终止线程太过暴力，有可能引发数据不一致问题。

```java
public class UnsafeStopThreadSample {
    static User user = new User();

    public static void main(String[] args) throws InterruptedException {
        Thread readThread = new Thread(new ReadTask());
        readThread.start();
        while (true) {
            WriteThread writeThread = new WriteThread();
            writeThread.start();
            Thread.sleep(150);
            writeThread.stopMe();
        }
    }

    public static class ReadTask implements Runnable {

        @Override
        public void run() {
            while (true) {
                synchronized (user) {
                    if (user.getAge() != Integer.parseInt(user.getName())) {
                        System.out.println("age: " + user.getAge() + ";name:" + user.getName());
                    }
                }
                Thread.yield();
            }
        }
    }

    public static class WriteThread extends Thread {

        // 正确的停止一个线程的方法
        volatile boolean stop = false;
        public void stopMe() {
            stop = true;
        }

        @Override
        public void run() {
            while (true) {
                if (stop) {
                    System.out.println("Thread-" + Thread.currentThread().getName() + " exit");
                }
                synchronized (user) {
                    int v = (int) (System.currentTimeMillis() / 1000);
                    user.setAge(v);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    user.setName(String.valueOf(v));
                }
                Thread.yield();
            }
        }
    }
    @Data
    public static class User {
        int age;
        String name;

        public User() {
            this.age = 0;
            this.name = "0";
        }
    }
}
```
### 线程中断

线程中断并不会是线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出。有关线程中断

有个三个方法:

```java
// 中断线程，设置中断标志位
public void Thread.interrupt(); 
// 判断是否被中断，通过中断标志位判断
public boolean Thread.isInterrupted(); 
// 判断是否被中断，并清除中断状态
public static boolean Thread.interrupted();
```

**举个🌰:**

```java
public class ThreadInterrupt {

    public static void main(String[] args) throws InterruptedException {
        //testInterrupt();
        testSleepInterrupt();
    }

    public static void testSleepInterrupt() throws InterruptedException {
        Thread t = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + " exit");
                    break;
                }
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    // sleep被中断抛出异常，中断标志位被清除，所有线程不会退出
                    System.out.println("Interrupted when sleep");
                    // 要保证sleep被中断，线程退出，需要设置中断标志
                    Thread.currentThread().interrupt();
                }
                Thread.yield();
            }
        });
        t.start();
        Thread.sleep(2000);
        t.interrupt();
    }

    public static void testInterrupt() throws InterruptedException {
        Thread t = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + " exit");
                    break;
                }
                Thread.yield();
            }
        });

        t.start();
        Thread.sleep(2000);
        t.interrupt(); // 执行interrupt方法，设置中断标志位
    }
}
```

### wait 和 notify 方法
这两个方式不是Thread类的，是Object类的。

当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。只要在其他线程线程调用了notify()方法为止，当前线程才有可能继续往下执行。

工作原理:
> 如果一个线程调用了个object.wait()方法，那么它就会进入object对象的等待队列。这个队列会有多个线程，因为系统运行多个线程同时等待某个对象。当object.notify()方法被调用时，它就会从这个等待队列中随机选择一个线程，并将其唤醒。这里的选择是不公平的。

对应的，还有个notifyAll()方法，它会唤醒所有的等待线程。需要注意的是，在调用wait()或者notify()方法前，需要获取到object这个对象锁。执行了wait()方法之后，线程会释放对象锁。

wait()方法和sleep()方法的区别:
> wait()和sleep()方法都可以让线程等待若干时间，wait()方法可以被唤醒，且会释放目标对象的锁。

```java
public class ThreadWaitAndNotify {
    private static Object obj = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (obj) {
                System.out.println("t1 get object lock: " + System.currentTimeMillis());
                try {
                    obj.wait();
                    System.out.println("t1 end: " + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (obj) {
                System.out.println("t2 get object lock: " + System.currentTimeMillis());
                obj.notify();
                try {
                    System.out.println("t2 end: " + System.currentTimeMillis());
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t1.start();
        t2.start();
    }
}
```

### 线程的挂起(suspend)和继续执行(resume)
被挂起的线程，必须要等到resume()方法执行之后才能继续执行。suspend()方法在导致线程暂停同时，不会释放任何锁资源。使用suspend()方法需要慎重，如果错误的执行了resume()方法(resume在suspend前执行)，可能会导致整个程序进入死锁的状态 。因为线程被挂起，不会释放任何锁资源，且需要线程执行resume方法才能继续执行。

### 等待线程结束(join)和谦让(yeild)
join()方法表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕。yeild()方法给出一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程会因为等待超时，而继续往下执行。

```java
public class ThreadJoinAndYeild {

    volatile static int i= 0;

    public static void main(String[] args) throws InterruptedException {
        AddThread t = new AddThread();
        t.start();

        // 如果在这里不执行join方法，输出的i可能是0或者是一个非常小的数
        t.join();
        System.out.println(i);
    }

    static class AddThread extends Thread {
        @Override
        public void run() {
            for (i=0; i < 10000; i++);
        }
    }
}
```

yeild()方法一旦执行，它会使得当前线程让出cpu。让出之后并不代表当前线程不执行了，当前线程让出cpu后，还会进行cpu资源争夺，但是能不能分配到资源就不一定了。

### 线程优先级
Java中使用1到10表示线程优先级。一般可以使用内置的三个静态标量表示:

```java
/**
 * The minimum priority that a thread can have.
 */
public final static int MIN_PRIORITY = 1;

/**
 * The default priority that is assigned to a thread.
 */
public final static int NORM_PRIORITY = 5;

/**
 * The maximum priority that a thread can have.
 */
public final static int MAX_PRIORITY = 10;
```

数字越大则优先级越高，有限范围在1到10之间，默认为5；

```java
public class ThreadPriority {

    private static Object obj = new Object();
    private static double lowFaster = 0;
    private static double highFaster = 0;
    private volatile static long lowFinishTime = 0;
    private volatile static long highFinishTime = 0;
    public static void main(String[] args) throws InterruptedException {
        int runTimes = 100;
        for (int i = 0; i < runTimes; i++) {
            PriorityThread high = new PriorityThread();
            high.setPriority(Thread.MAX_PRIORITY);
            high.setName("highPriorityThread");

            PriorityThread low = new PriorityThread();
            low.setPriority(Thread.MIN_PRIORITY);
            low.setName("lowPriorityThread");

            low.start();
            high.start();

            low.join();
            high.join();
            
            // 记录不同优先级先完成的次数，然后作对比
            if (lowFinishTime - highFinishTime > 0) {
                lowFaster ++;
            } else {
                highFaster ++;
            }
        }

        System.out.println(lowFaster / runTimes);
        System.out.println(highFaster / runTimes);
    }

    static class PriorityThread extends Thread {
        static int count = 0;

        @Override
        public void run() {
            while (count > 10000) {
                synchronized (obj) {
                    count++;
                }
            }
            System.out.println(Thread.currentThread().getName() + " finished job");
            // 简单的记录完成jod的时间点
            if (Thread.currentThread().getName().equalsIgnoreCase("lowPriorityThread")) {
                lowFinishTime = System.currentTimeMillis();
            } else {
                highFinishTime = System.currentTimeMillis();
            }
        }
    }
}
```













