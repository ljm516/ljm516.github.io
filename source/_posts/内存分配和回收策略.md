---
title: 内存分配和回收策略
date: 2019-06-20 21:24:44
tags:
- JVM
---

在Java中，JVM是怎样给对象分配内存，又是如果对内存进行回收的呢？

<!--more-->

对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况也可能直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的哪种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

## 对象优先在Eden分配
大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将发起一次Minor GC。

## 大对象直接进入老年代
所谓的大对象，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来存储这些大对象。

## 长期存活的对象将进入老年代
虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一些对象年龄计数器。如果对象在Eden出生并经过第一次Minor Gc后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象每再Survivor区中经历一次Minor Gc，年龄就增加一岁，当它的年龄增加到一定的程度（默认15），将会晋升到老年代。

## 动态对象年龄判定
为了能更好的适应不同的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到
MaxTenuringThreshold中要求的年龄。

## 空间分配担保
在发生Minor Gc之前，虚拟机会先检查老年代最大连续空间是否大于新生代所有对象空间，如果这个条件成立，那么Minor Gc可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年大最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试一次Minor Gc，尽管这次Minor Gc是有风险的；如果小于，或者HandlePromotionFailure设置不允许，则这时就要改为进行一次Full Gc。