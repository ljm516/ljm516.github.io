---
title: HotSpot中的对象
date: 2019-04-23 23:13:24
categories: Java
tags:
- JVM
---

本文记录阅读周志明老师的《深入理解Java虚拟机》的HotSpot中的对象探秘笔记，从对象的创建，内存布局和对象访问做笔记。

<!--more-->

## 对象的创建

创建流程

![对象的创建流程](对象创建.jpg)

1. 没有对象怎么办，那就new一个
当虚拟机遇到一个new 指令，会去检查这个指令参数在能否在常量池中定位到一个类的符号，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，则执行类的加载过程。
2. 为对象分配内存
在类加载完成后，对象所需的内存就确定了，为对象分配内存就是在java堆类划出一块确定大小的内存空间。为对象分配空间的算法有两种：指针碰撞和空闲列表。指针碰撞的前提是Java堆中的内存是绝对规整的，用过的内存放在一边，空闲的内存放在另一边，当为新对象分配内存，只需要移动响应内存大小的距离就行。空闲列表需要虚拟机维护一个列表，记录那些内存是可用的，分配内存时，从列表中找到一块足够大的空间划分给对象实例，然后更新列表。Java堆是否规整，由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew等带Compact过程的收集器，通常采用指针碰撞算法，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
3. 对象初始化
完成上面的步骤，从虚拟机的角度来讲，一个新的对象就产生了，但是从程序角度来说，对象的创建才刚开始，对象的所有属性都是默认值，接下来就是执行init操作，把对象按照程序员的意愿进行初始化。

## 对象内存结构
可分为3块区域：对象头、实例数据、对齐填充。

1. 对象头
分为两部分，第一部分用于存储对象自身的运行时数据，包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度在32位和64位虚拟机分别是32bit和64bit，官方称之为“Mark word”。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过它能确定这个对象时那个类的实例。
2. 实例数据
对象真正存储的有效信息，程序代码中所定义的各种类型的字段内容。
3. 对齐填充
并不是必然存在，仅仅起占位符的作用。HotSpot虚拟机自动内存管管理系统要求对象起始地址必须是8字节的整数倍，就是对象的大小必须是8字节的整数倍。对象头正好是8字节的整数倍，如果示例数据没有对齐，就需要通过对齐填充补全。
## 对象的访问定位
目前主流的两种定位方式:使用句柄和直接指针。

- 使用句柄
Java堆中会划出一块内存作为句柄池，reference中存储的是对象的句柄地址，句柄包含了对象
实例数据和类型数据各自的具体地址信息。

![使用句柄](句柄.jpg)

- 直接指针
Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址

![直接指针](直接指针.jpg)

### 两种方法的各自优点
使用句柄的好处：reference存储的是稳定的句柄地址，对象移动（GC）只会改变句柄中实例数据的数据指针，reference本身不用改变。
使用直接指针的最大好处就是快，它节省了一次指针定位的时间开销，在java中对象访问很频繁，这种开销积少成多后也是一项非常可观的执行成本。

HotSpot虚拟机使用的直接指针的方式进行对象访问的。

## 对象是否可回收
垃圾收集器在进行回收之前，第一件事就是要确定那些对象是”存活“的，那些是“死亡”的。

### 引用计数算法
描述: 给对象中添加一个引用计数器，每当有个地方引用它时，计数器加1；当引用失效时，计数器减1。任何时刻计数器为0的对象就是不可能再被使用的。

#### 优缺点
- 优点: 实现简单，判定效率高
- 缺点: 无法解决相互循环引用的问题。例如 A引用B，B引用A，然后再无其它引用，实际上这两个对象已经不可能再被访问，但是它们又保持各自的引用，导致引用计数器不为0，GC也就无法回收它们。
### 可达性分析算法
这个算法的基本思路就是通过一系列的“GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种:
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态引用的对象。
- 方法区中常量引用的对象。
- 本地方法中JNI引用的对象。

## 引用
对象引用可分为强引用、软引用、弱引用、虚引用四种，引用强度依次降低。
- 强引用就是指程序代码之中普遍存在的，类似”Object obj = new Object()“这类的引用，只要强引用还存在，GC就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被软引用关联的对象。
- 虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。