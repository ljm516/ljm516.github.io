---
title: Java设计模式之工厂模式
date: 2017-11-10 13:30
categories: Java
tags:
- 设计模式
---

工厂模式主要是为创建对象提供过渡接口，以便将创建的具体过程屏蔽隔离起来，达到提高灵活性的目的。

<!-- more -->

## 分类

* 简单工厂模式（Simple Factory）
* 工厂方法模式（Factory method）
* 抽象工厂模式（Abstract Factory）

简单工厂模式是工厂方法模式的一种特例。

## 传统创建对象的方式

```java
class BenzCar {
    public void info () {
        System.out.print("this is a Benz");
    }
}

class BmwCar {
    public void info () {
        System.out.print("this is a Bmw");
    }
}

public class Customer {
    public static void main (String[] args) {
        BenzCar benz = new BenzCar();
        BmwCar bmw = new BmwCar();
        
        benz.info();
        bmw.info();
    }
}
```

类`Customer`需要知道怎么去创建一款车，`Customer`和车就紧密耦合在一起了。为了降低耦合度，就出现了工厂类，把创建车的操作细节都放到工厂类里面，`Customer`类直接使用工厂的创建工厂方法，传入想要的车类型就好了。

## 简单工厂模式

简单工厂模式又称为静态工厂方法模式。它存在的目的很简单：定义一个用于创建对象的接口。

先来看看它的组成:

* 工厂类角色：这是本模式的核心，在Java中往往由一个具体类实现。
* 抽象产品角色：一般是具体产品继承的父类或者实现的接口。在Java中由接口或者抽象类实现
* 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。

```java
// 抽象产品角色
public interface Car {
    public void info();
}

// 具体产品类
public class BenzCar implements Car {
    
    @override
    public void info() {
        System.out.print("this is Benz");
    }
}

public class BmwCar implements Car {
    
    @override
    public void info() {
        System.out.print("this is Bmw");
    }
}

// 工厂类角色
public class CarFactory {
    // 返回类型必须为抽象产品角色
    public static Car createCar(String type) {
        // 判断逻辑，返回具体的产品角色
        if (type.equals("BenzCar")) {
            return new BenzCar();
        }
        if (type.equals("BmwCar")) {
            return new BmwCar();
        }
        
        return null;
    }
}

// 创建者
public class Customer {
    Car car = CarFactory.createCar("BenzCar");
    car.info()
}
```

这就是简单工厂模式，那么它的优点有那些？

首先，使用了简单工厂模式后，`Customer`就免除了直接创建对象的责任，而是仅仅消费对象。

从开放关闭原则来看，当`Customer`不再满足现有的车型，想要一款新型的车，只要这种车符合抽象产品指定的合同，那么只要通知工厂类知道就可以被`Customer`消费了。所以对产品部分来说，它是符合开放关闭原则的；但是工厂部分好像不太理想，因为没增加一种新型车，都要在工厂类中增加相应的创建业务逻辑，这显然是违背开放关闭原则的。

## 工厂方法模式

工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。

工厂方法模式的结构组成:

* 抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者继承的父类。在java中它由抽象类或者接口来实现。
* 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
* 抽象产品角色：它是具体产品继承的父类或者实现的接口。在java中一般由抽象类或者接口实现。
* 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

```java
// 抽象产品角色
abstract class Car {
    abstract void info();
}

// 具体产品角色
public class BenzCar extends Car { 
    @override
    public void info() {
        System.out.print("this is Benz");
    }
}

public class BmwCar extends Car { 
    @override
    public void info() {
        System.out.print("this is Bmw");
    }
}

// 抽象工厂角色，用来生产车
public interface AbstractFactory {
    Car carFactory();
}

// 具体工厂角色， 创建具体类型的车
public class BenzCarFactory implements AbstractFactory {
    @override
    public Car createBenzCar() {
        return new BenzCar();
    }
}

public class BmwCarFactory implements AbstractFactory {
    @override
    public Car createBmwCar() {
        return new BmwCar();
    }
}
 
// 消费者
public class Customer {
    private static Car benzCar, bmwCar;
    private static AbstractFactory benzCarFactory, bmwCarFactory;
    
    public static void main(String[] args) {
        benzCarFactory = new BenzCarFactory();
        bmwCarFactory = new BwmCarFactory();
        
        BenzCar benz = benzCarFatory.createBenzCar();
        benz.info();
        
        BwmCar bmw = bmwCarFactory.createBmwCar();
        bmw.info();
    }
}   
```

工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的唯一工厂类。这样使得结构灵活起来--当有新的产品产生时，只要按照抽象产品角色、
生成具体的实现类，那么久可以被消费者使用了，而不必去修改任何已有的代码。

## 抽象工厂模式

抽象工厂模式的用意为: 给客户端提供一个接口，可以创建多个产品族中的产品对象。

而且使用抽象工厂模式还要满足一些条件:

* 系统中有多个产品族，而系统一次只能消费其中一族产品。
* 同属于同一个产品族的产品以其使用。

来看看抽象工厂模式的各个角色:

* 抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口实现。
* 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
* 抽象产品角色：它是具体产品继承的父类或者实现的接口。在java中一般由抽象类或者接口实现。
* 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

```java
// 抽象工厂类，定义不同的产品之间的标准
public interface BusinessCar { 
    public void info();
}

public interface SportsCar {
    public void info();
}

// 具体产品类
public class BenzBusinessCar implements BusinessCar {
    @override 
    public void info() {
        System.out.print("this is Benz-商务车");
    }
}

public class BmwBusinessCar implements BusinessCar {
    @override 
    public void info() {
        System.out.print("this is Bmw-商务车");
    }
}

public class BenzSportsCar implements SportsCar {
    @override 
    public void info() {
        System.out.print("this is Benz-跑车");
    }
}

public class BmwSportsCar implements SportsCar {
    @override 
    public void info() {
        System.out.print("this is Bmw-跑车");
    }
}

// 抽象工厂类，创建跑车
public abstract class SportsCarAbstractFactory {
    abstract SportsCar getBenzSportsCar();
    abstract SportsCar getBmwSportsCar();
}

// 抽线工厂类，创建商务车
public abstract class BusinessCarAbstractFactory {
    abstract BusinessCar getBenzBusinessCar();
    abstract BusinessCar getBmwBusinessCar();
}

// 具体工厂类，创建跑车
public class SportsCarFactory extends SportsCarAbstractFactory {
    @override
    SportsCar getBenzSportsCar() {
        return new BenzSprotsCar();
    }
    
    @override
    SportsCar getBmwSportsCar() {
        return new BmwSprotsCar();
    }
}

// 具体工厂类，创建商务车
public class BusinessCarFactory extends BusinessCarAbstractFactory {
    @override
    BusinessCar getBenzBusinessCar() {
        return new BenzBusinessCar();
    }
    
    @override
    BusinessCar getBmwBusinessCar() {
        return new BmwBusinessCar();
    }
}

// 消费者
public class Customer {
    public static void main(String[] args) {
    
        SportsCarFactory sportsCarFactory = new SportsCarFactory();
        BusinessCarFactory businessCarFactory = new BusinessCarFactory();

        SportsCar benzSportsCar = sportsCarFactory.getBenzSportsCar();
        SportsCar bmwSportsCar = sportsCarFactory.getBMWSportsCar();

        BusinessCar bmwBusiness = businessCarFactory.getBMWBusinessCar();
        BusinessCar benBusiness = businessCarFactory.getBenzBusinessCar();

        benzSportsCar.info();
        bmwSportsCar.info();
        bmwBusiness.info();
        benBusiness.info();
        
    }
}
     
```

## 区别

工厂方法模式:

一个抽象产品类，可以派生出多个具体的类。
一个抽象工厂类，可以派生出多个具体的工厂类。
每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式:

多个抽象产品类，每个抽象产品类可以派生出多个具体的产品类。
一个抽象工厂类，可以派生出多个具体工厂类。
每个具体工厂类可以创建多个具体产品类的实例。

区别：

* 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。
* 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个具体产品类的实例。

