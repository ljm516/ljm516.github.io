---
title: 2017年Java开发岗位面试题回答(基础篇)
date: 2017-11-15 11:15
categories: Java
tags:
- 面试题
---

题目来源于[百面网](http://www.100mian.com/mianshi/java/50036.html)

<!-- more -->

## String 为什么是 final 的

**不可变类只是其实例不能被修改的类。**

从这5个方面讲

- 不要提供任何会修改对象状态的方法
- 保证类不会被扩展
- 是所有的域都是final的
- 是所有的域都成为私有的
- 确保对于任何可变性组件的互斥访问。

先看看 String 类的定义，String 类是由 final 修饰的，保证不会被继承。

再看看它是怎样实现的:

private final char value[]: Java是基于字符数组实现字符串的，并且是有 final 修饰，保证其不可变性。这就是为什么 String 实例不可变得原因。

字符数组代表了 String 对象的值。由于是 private final 修饰的，正常情况下外界没有办法去修改它的值。保证所有的域都是 final 的以及所有的域（属性）都是私有的。

String 类没有提供任何会修改其状态的方法。 replace()、subString()、concat() 的内部实现都是返回了一个新的字符串。

**不可变类的好处**

- 本质上是线程安全的，不要求同步，可以被自由的共享。

**破坏 String 的不可变**

```java
public static void breakStringUnChanged() throws Exception {
   String str1 = "ljming";
   System.out.println(str1);
   Field value = String.class.getDeclaredField("value");
   value.setAccessible(true);
   char c[] = (char[]) value.get(str1);
   c[1] = 'm';
   System.out.println(str1);
}
```

## HashMap 的实现原理，底层结构

HashMap 底层是数组+链表的数据结构。

### put 方法的内部实现

首先计算 key 的 hash 值，通过该 hash 值找到该值在数组的存储位置，在对应位置中存储了表示这个值的 node 节点，节点内容包括 key 值和 Value 值。如果出现不同的 key，但是计算出来的 hash 值是相同的，想通过 hash 值找到相对应的存储位置，然后在这个位置以链表的形式存储两个值，如果链表的长度大于等于8，为了优化检索速度，将以红黑二叉树的形式存储。

### get 方法的内部实现

首先通过 key 计算出 hash 值，通过这个 hash 值找到对应位置的节点。它总是会先判断头节点是不是要查找的值，如果是，直接返回，否则，循环节点，知道找到和 key 值相等的节点，并返回。如果没找到，就返回 null。

## 描述一下 ArrayList 和 LinkedList 各自的实现和区别

### ArrayList 的实现

内部使用数组进行数据存储。

### LinkedList 的实现

内部使用链表进行数据存储。

### 区别

* 在插入数据方面，LinkedList 效率要高于 ArrayList。原因: LinkedList 插入数据时，只需要改变节点的 pre 和 next 的指向；而 ArrayList 在插入数据时，如果不是在尾部插入，需要挪动其它数据，给新加入的数据腾出位置，这样是很耗时的，而且如果出现 ArrayList 容量不足的情况下，还要进行数组扩容操作。
* 在获取数据方面，ArrayList 效率要高于LinkedList。原因: ArrayList 的 get(index) 方法可以直接返回该下标的值。而 LinkedList 需要循环遍历每个节点，从而找到对应的节点。

## Java 的队列有哪些，有什么区别。

阻塞队列BlockQueue

### ArrayBlockingQueue 和 LinkedBlockingQueue

顾名思义，ArrayBlockingQueue 是基于数组实现的，LinkedBlockingQueue 是基于链表实现的。ArrayBlockingQueue 更适合做有界队列，因为队列中可容纳的最大元素需要在队列创建的时候指定。而 LinkedBlockingQueue 适合做无界队列，其内部元素可以动态添加。

## 反射中，Class.forName 和 ClassLoader 的区别

### 先看一个例子

```java
public static void classLoaderTest() {
   try {
       Class clazz = Class.forName("com.javaReview.pattern.factoryPattern.factoryMethod.BenzCar");
       ClassLoader classLoader = ClassLoader.getSystemClassLoader();
       Class benzCar = classLoader.loadClass("com.javaReview.pattern.factoryPattern.factoryMethod.BenzCar");
       System.out.println(clazz.getSimpleName());
       System.out.println(benzCar.getSimpleName());
   } catch (ClassNotFoundException e) {
       e.printStackTrace();
   }
}
```

### 再看 Class.forName 的源码实现

```java
@CallerSensitive
public static Class<?> forName(String className)
           throws ClassNotFoundException {
   Class<?> caller = Reflection.getCallerClass();
   return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
}

@CallerSensitive
public static Class<?> forName(String name, boolean initialize,
                              ClassLoader loader)
   throws ClassNotFoundException
{
   Class<?> caller = null;
   SecurityManager sm = System.getSecurityManager();
   if (sm != null) {
       // Reflective call to get caller class is only needed if a security manager
       // is present.  Avoid the overhead of making this call otherwise.
       caller = Reflection.getCallerClass();
       if (sun.misc.VM.isSystemDomainLoader(loader)) {
           ClassLoader ccl = ClassLoader.getClassLoader(caller);
           if (!sun.misc.VM.isSystemDomainLoader(ccl)) {
               sm.checkPermission(
                   SecurityConstants.GET_CLASSLOADER_PERMISSION);
           }
       }
   }
   return forName0(name, initialize, loader, caller);
}

private static native Class<?> forName0(String name, boolean initialize, ClassLoader loader, Class<?> caller) throws ClassNotFoundException;
```

### 最后看 ClassLoader.loader 的实现

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
   return loadClass(name, false);
}

protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
   synchronized (getClassLoadingLock(name)) {
       // First, check if the class has already been loaded
       Class<?> c = findLoadedClass(name);
       if (c == null) {
           long t0 = System.nanoTime();
           try {
               if (parent != null) {
                   c = parent.loadClass(name, false);
               } else {
                   c = findBootstrapClassOrNull(name);
               }
           } catch (ClassNotFoundException e) {
               // ClassNotFoundException thrown if class not found
               // from the non-null parent class loader
           }

           if (c == null) {
               // If still not found, then invoke findClass in order
               // to find the class.
               long t1 = System.nanoTime();
               c = findClass(name);

               // this is the defining class loader; record the stats
               sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
               sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
               sun.misc.PerfCounter.getFindClasses().increment();
           }
       }
       if (resolve) {
           resolveClass(c);
       }
       return c;
   }
}

```

### 总结

- class.forName(String className) 使用默认的加载器来加载类，并且进行初始化
- class.forName(String className, boolean initialize, ClassLoader loader) 可以指定加载器和是否初始化。
- classLoader.loadClass(String name) 先判断类是否已经加载，如果已经加载，不处理，反则加载类。不会实例化。

区别： 

* Class.forName 可指定加载器，loadClass 不能。
* Class.forName 可指定时候初始化类，而 loadClass 不初始化类。如果客户端代码需要依赖类的实例，就只能使用Class.forName, 并指定 initialize 为 true。


## Java7、8的新特性

### Java7 新特性

- switch 增加对 String 类型的支持
- catch子句可以同时捕获多个异常

### Java8 新特性

- Lambda 表达式
- 接口中的默认方法: Java 8准许我们在接口中增加一个通过default关键字修饰的非抽象的方法
- Stream API, 并行流

## Java 内存泄漏的问题调查定位： jmap, jstack 的使用。

这个还真不知道！好吧，Google 一下。

### jstack 

主要用来查看某个 Java 进程内的线程堆栈信息。

语法格式

```
jstack [option] pid
jstack [option] executable core
jstack [option] [server-id@]remote-hostname-or-ip
```
jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码。

### jmap

jmap 用来查看堆内存使用状况，一般结合jhat使用。

语法格式

```
jmap [option] pid
jmap [option] execute core
jmap [option] [server-id@] remote-hostname-or-ip
```
使用jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况

## String，StringBuilder，StringBuffer 的区别

- String 不可变， StringBuilder 和 StringBuffer 可变
- StringBuilder 非线程安全，StringBuffer 线程安全（内部方法都使用了 Synchronized 修饰）。

## HashTable 和 HashMap 的区别

- HashTable 是线程安全的，HashMap 是非线程安全的。
- HashMap 允许 null key 和 null value，HashTable 不允许。
- 因为 HashTable 线程安全，所以效率要比 HashMap 低。

## 异常结构、运行时异常和非运行时异常，举例子

## String 类的常用方法

- boolean equals()
- int hashcode()
- String toString()

.... 看 String 类的源码

## Java 的引用类型有哪几种

### 强引用

强引用也就是我们平时的 A a = new A();

使用最普遍的引用，如果一个对象具有强引用，那GC绝不会回收它。JVM情愿抛出OutOfMemoryError 错误，使程序异常终止，也不会靠随意会有具有强引用的对象来解决内存不足的问题。

### 软引用

如果一个对象只具有软引用，则内存足够的情况下，GC不会去回收它，否则，就会回收这些对象。

### 弱引用

弱引用和软引用的区别：只具有弱引用的对象拥有更短暂的生命周期，在GC线程在它管辖的内存区域过程中，一旦发现了只具有弱引用的对象，不管当前内存空间时候足够，都会回收它的内存。

### 虚引用

和其他几种引用不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被GC回收。

## 抽象类和接口的区别

- 抽象类中可以包含非抽象方法，接口只能有抽象方法(1.8允许一个非抽象的默认方法)
- 接口里面只能对方法进行声明，抽象类既可以对方法进行声明也可以对方法进行实现。
- 一个类只能继承一个类，但可以实现多个接口

## Java 的基本类型和字节大小


| 类型 | 大小(字节) |
| --- | --- |
| int | 4 |
| char | 2 |
| byte | 1 |
| short | 2 |
| long | 8 |
| float | 4 |
| double | 8 |
| boolean | 4 |

## HashTable、HashMap、ConcurrentHashMap 底层实现原理与线程安全问题

这个，呃。。。 还是看源码吧。

## 自己实现 HashMap

mmp, 这就有点难了。

## Hash 冲突了怎么办，那些解决 hash 冲突的方法

- 开放地址法

开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,...,k(k<=m-1)。其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,...k`*`k,-k`*k`(k<=m/2) 
称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。

- 再 hash 法

当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。

- 链地址法

所有 key 的 hash 值相同的记录存储在同一线性链表中。

- 建立一个公共溢出区

假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。

mmp的。 只看懂了2和3。

