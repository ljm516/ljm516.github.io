---
title: Java内存管理和volatile关键字
date: 2019-07-10 00:13:56
categories: Java
tags:
- 多线程
---
深入理解Java内存管理（JMM）以及volatile关键字的作用。

<!--more-->

## Java内存模型
Java memory model（JMM）的主要目标是定义程序中各个变量的规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里的变量包含实例变量、静态字段和构成数组的对象的元素，但不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，也就不存在竞争问题。

JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存保存了被被该线程使用的变量的主内存拷贝副本，线程对变量的所有读写操作都基于自己的工作内存，不能直接操作主内存的变量。不同线程直接也无法直接诶访问其它线程的工作内存中的变量，线程中的变量传递需要通过主内存来完成。下图展示工作内存和主内存的交互关系:
![主内存和工作内存](主内存和工作内存.png)
Java主内存主要对应堆中的对象实例数据部分，而工作内存则对应虚拟机栈中的数据部分。

## 内存间的交互操作
Java中关于主内存和工作内存的交互协议，JMM中定义了一下8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的，不可再分的（double和long类型例外）。
- lock(锁定): 作用于主内存的变量，把一个变量标识为一条线程独占的状态。
- unlock(解锁): 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。
- read(读取): 作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用过。
- load(载入): 作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use(作用): 作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign(赋值): 作用与工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store(存储): 作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- write(写入): 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作；如果把变量从工作内存同步到主内存，就要顺序的执行store和write操作。另外，JMM还规定了在执行上述8中基本操作时必须满足如下规则:
- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况。
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生任何assign操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load和assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量值。
- 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许unlock一个被其它线程锁住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步会主内存中。

## volatile关键字
关键字volatile可以说是Java提供的最轻量级的同步机制。当一个变量被volatile修饰之后，它将具备两种特性: ①保证此变量对所有线程的可见性，指的是当某个线程修改了这个变量的值，新值对于其它线程来说是可以立即得知的。而普通变量不能做到这一点，需要通过线程间的传递，先写回主线程，其它线程在从主线程读取；②使用volatile关键字可以禁止指令排序优化。

### 保证可见性
volatile的可见性，不能保证并发下的运算时安全的。volatile变量在各个线程的工作内存中不存在一致性的问题，但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。
```java
public class VolatileDemo {
    private static volatile int i;
    static CountDownLatch countDownLatch = new CountDownLatch(10);
    public static void main(String[] args) throws InterruptedException {
        Task task = new Task();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(task);
            t.start();
        }
        countDownLatch.await();
        System.out.println(i);
    }
// 执行自增操作
    static class Task implements Runnable {
        @Override
        public void run() {
            for (int j = 0; j < 10000; j++) {
                i++;
            }
            countDownLatch.countDown();
        }
    }
}
```
上面这个例子，创建了10个线程，每个线程对i进行自增10000，变量i是volatile修饰的。运行结果且不等得到100000的结果，而是一个小于这个值的结果。
![volatile自增](volatile自增.png)
当getstatic执行把i的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其它线程可能已经把i的值加大了，这是操作栈顶的值就变成了过期的数据，执行putstatic执行时，就可能把较小的i值同步回主内存中。

由于volatile只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要通过加锁来保证原子性。
- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
- 变量不需要与其它的状态变量共同参与不变约束。

### 禁止执行排序优化
普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。

```java
public static Object getInstance() {
    if (null == instance) {
        synchronized (lock) {
            if (null == instance) {
                instance = new Object();
            }
        }
    }
    return instance;
}
```
这是经典的Double-check的单例模式，如果instance没有使用volatile修饰，就有可能获取到一个不正常的对象（虽然测试没有出现过）。这是应为instance = new Object()这一步不是一个原子的操作，这一步JVM大概做了以下三件事:
- 给instance分配内存
- 调用instance的构造函数初始化成员变量
- 将instance对象指向分配的内存空间（这个时候instance才非null）
由于有可能发生过指令重排，第二步和第三步的顺序不能保证，如果第三步在第二步前执行，这时另一个线程获取到锁，发现instance不为null，就返回了instance，但是返回的是一个还未初始化完成的对象。如果instance声明为volatile，保证了指令的执行的顺序，也就不会出现读取到一个不正常的对象。

## 原子性、可见性、有序性

### 原子性
JMM直接保证的原子性变量操作有read、load、assign、use、store、write。如果应用场景需要一个更大范围的原子性操作，JMM还提供了lock和unlock操作来满足需求，尽管虚拟机没有将lock和unlock操作直接开放给用户使用，但是提供了更高级的monitorenter和monitorexit指令隐式的使用这两个操作。这两个指令反映到Java代码中就是同步块--Synchronized关键字，因此Synchronized块之间的操作也具备原子性。
### 可见性
指的是当一个线程修改了共享变量的值，其它线程能立即得到这个修改。JMM是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。如论是普通变量还是volatile变量都是如此。volatile变量的和普通变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。
### 有序性 
Java程序中天然的有序性可以总结为一句话:如果在本线程内观察，所有的操作都是有序的；如果在一个线程中该观察另一个线程，所有的操作都是无序的。前半句是值”线程内表现为串行的语义“，后半句是值“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java提供了volatile和Synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而Synchronized关键字则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这个规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行的进入。

## happen-before（先行发生）原则
happen-before原则是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则可解决并发环境下两个操作之间是否可能存在冲突的所有问题。

happen-before是Java内存模型中定义的两项操作之间的额偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生过的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了信息、调用了方法等。
```
// 线程A中执行
int i = 0;
// 线程B中执行
int j = i;
// 线程C中执行
i= 1;
```
假设线程A中的操作先行发生于B的操作，那么可以确定在B的操作执行后，变量j的值一定等于0。因为根据先行发生原则，“i=0”的结果可以被观察到，这是还不考虑线程C，除了A之后没有其它线程会修改i的值。现在在把C考虑进来，A和B保持先行发生关系，但是C和B没有先行发生关系，那j的值有可能是0，有可能是1，因为C对i的影响有可能被B观察到，也有可能不会。

JMM有一下天然的happen-before关系，无需同步协助器，可以直接使用。
- 程序次序规则: 在一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于书写在后面的操作。
- 管程锁定规则: 一个unlock操作先行发生于后面对同一锁的lock操作。这里强调的是同一个锁，“后面”是值时间上的先后顺序。
- volatile变量规则: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则: Thread对象的start方法先行发生于此线程的每个动作
- 线程终止规则: 线程中的所有操作都先行发生于此线程的终止检测。
- 线程中断规则: 对线程interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
- 对象终结规则: 一个对象的初始化完成先行发生于它的finalize方法的开始
- 传递性: 如果操作A先行发生于操作B，B先行发生于操作C，那么A先行发生于C。





