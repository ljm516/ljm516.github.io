---
title: MySQL事务实现原理
date: 2020-01-09 11:50:07
tags:
---
MySQL的InnoDB存储引擎中的锁和事务。

<!--more-->

## InnoDB中的锁
InnoDB存储引擎实现如下两种行级锁:
- 共享锁（S Lock），允许事务读一行数据
- 排它锁（X Lock），允许事务删除或更新一行数据

--- | X | S | 
---|---|---
X | 不兼容 | 不兼容
S | 不兼容 | 兼容

上表中的S和X锁都是行级别的锁，InnoDB也支持多粒度的锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB提供了一种称之为意向锁的锁方式。意向锁是表级别的锁，支持两种意向锁:
- 意向共享锁，事务想获取一张表中某几行的共享锁。
- 意向排它锁，事务想获取一张表中某几行的排它锁。

由于InnoDB支持的行级别的锁，因此意向锁不会阻塞除全表扫描以外的任何请求。故表级意向锁和行级锁的兼容性如下:

--- | IS | IX | S | X 
---|---|---|---
IS | 兼容 | 兼容 | 兼容 | 不兼容 
IX | 兼容 | 兼容 | 不兼容 | 不兼容 
S | 兼容 | 不兼容 | 兼容 | 不兼容
X | 不兼容 | 不兼容 | 不兼容 | 不兼容

### 一致性非锁定读
一致性非锁定读是指InnoDB通过多版本控制的方式来控制当前执行时间数据库中的行数据。如果读取的行正在执行Delete或者Update操作，这时读取操作不会因此去等待行上锁的释放。而是回去读取一个快照数据。之所以称为非锁定读，是因为不需要等到访问的行上的X锁释放。
![](一致性非锁定读.png)
不同的事务隔离级别下，读取的方式不同，并不是每个事务隔离级别下都是采用非锁定的一致性读。

快照数据其实是当前行数据的之前的历史版本，每行记录可能有多个版本，一般称为这种技术为多版本控技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrent Control, MVCC)。

在事务隔离级别Read Committed(RC)和Repeatable Read（InnoDB默认,RR）下，InnoDB使用非锁定的一致性读。但是对快照数据的定义却不同。在RC事务隔离级别下，对于快照数据，非一致性锁定读总是读取被锁定的最新一份快照数据。而在RR事务隔离级别下，对于快照信息，非一致性锁定读总是读取事务开始时的行数据版本。

![](rc&rr.png)
上图展示了RC和RR两种事务隔离级别的不同之处。在事务B对a进行了修改并提交之后，RC由于读取的是最新的快照数据，所以读出来a的值为bbb。而RR读取的是当前事务开始的版本数据，所以还是xxx。RC的事务隔离级别，从数据库理论角度上看，违反了事务ACID的I（隔离性）的特性。

### 一致性锁定读
在某些情况下，用户需要显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于select的只读操作。InnoDB对于select语句支持两种一直性格的锁定读操作:
- select...for update
- select...lock in share mode

### 行锁的3种算法
InnoDB有3中行锁的算法，分别是:
- Record Lock: 单个记录的锁
- Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身 
- Next-key Lock: Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

Record Lock总是会去锁住索引记录。如果建表的时候没有创建任何索引，会使用隐式的主键来进行锁定。
在Next-key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。采用Next-key Lock的锁定技术成为Next-key Locking。设计目的是为了解决phantom problem(幻读问题)。它锁住的是一个范围，而不是单个记录。

但是在查询的索引含有唯一属性时，InnoDB会对Next-key lock进行优化，将其降级为Record Lock。

#### 幻读（不可重复读）
幻读问题指的是在同一事务下，连续执行两次同样的SQL语句，可能导致不同的结果。不可重复读的条件是事务隔离级别为RC。

在默认的事务隔离级别RR下，InnoDB采用Next-key Locking机制来避免幻读问题。Next-key Locking算法锁住的不是单个值，而是一个范围，在这个范围的插入是不被允许的，从而避免了幻读的问题。

而在RC的事务隔离级别下，采用的是Record Lock。

#### 脏读
脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据。
![](脏读.png)
上图展示了脏读的过程，事务B读到了事务A没有提交的数据。脏读发生的条件是事务隔离级别为Read Uncommitted(读未提交，RUC)。

## 事务
事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务操作中，要么都执行，要么都不执行。

InnoDB中的事务完全符合ACID的特性。
- 原子性(atomicity)
- 一致性(consistency)
- 隔离性(isolation)
- 持久性(durability)

### 事务特性

#### 原子性
原子性指整个数据库事务是不可分割的工作单元。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

#### 一致性
一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

#### 隔离性
事务的隔离性要求每个读写事务的对象对其它事务的操作对象能相互分离，及该事务提交前对其它事务都不可见，通常这是用锁来实现。

#### 持久性
事务一旦提交，其结果是永久性的。即使发生宕机等故障，数据也能将数据恢复。

### 事务的实现
事务隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。redo log称为重做日志。用来保证事务的原子性和持久性。undo log用来保证事务的一致性。

#### redo
重做日志用来实现事务的持久性，即事务ACID的D。由两个部分组成:一是内存中的重做日志缓冲，其是易失的；而是重做日志文件，其是持久的。
为了确保每次日志都写入重做日志文件，在每次重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作。参数`innodb_flush_log_at_trx_commit`用来控制重做日志刷新到磁盘的策略。该参数的默认值为1，表示事务提交时必须调用一次fsync操作。还可设置为0和2。0表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中每1秒会进行一次重做日志文件的fsync操作。2表示事务提交时讲过重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。在这个设置下，如果发生宕机，重启数据库会丢失未从文件系统缓存刷新到重做日志的那部分日志。

#### undo
事务有时候需要做回滚操作，这是就需要undo。因此在对数据库进行修改时，InnoDB不但会产生redo，还会产生一定量的undo。这样如果用户执行事务或者语句时由于某种原因失败了，又或者用户用一条Rollback语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

undo存放在数据中的一个特殊段（segment）中，这个段称为undo段。

### 事务隔离级别
SQL标准定义的四个隔离级别为：
- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable




