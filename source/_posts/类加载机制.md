---
title: 类加载机制
date: 2019-06-02 22:35:59
tags:
- JVM
---

JVM如果加载class文件？

<!--more-->

类的生命周期: 加载、验证、准备、解析、初始化、使用、卸载共7个阶段。

## 类加载的过程

- 加载
    在加载阶段，虚拟机需要完成以下3件事情:
    * 通过一个类的全限定名来获取定义此类的二进制字节流。
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。
- 验证
    这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    
    1. 文件格式验证
        这个阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面的这些验证点:
        - 是否以魔数0xCAFEBABE开头。
        - 主、次版本号是否在当前虚拟机处理范围之内。
        - 常量池的常量中是否有不被支持的常量类型。
        - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
        ...
        
        该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。
    2. 元数据验证
        这个阶段是对字节码描述信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下:
        - 这个类是否有父类。
        - 这个类的父类是否继承了不允许被继承的类。
        - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
        - 类中的字段、方法是否与父类产生矛盾
        ...
        
        第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
    3. 字节码验证
        第3阶段的目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如:
        - 保证任意时刻操作数栈的数据类型于指令代码序列都能配合工作。
        - 保证跳转指令不会跳转到方法体外字节码指令上。
        - 保证方法体中的类型转换是有效的。
        ...
    4. 符号引用验证
        最后一个阶段校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。符号引用验证可以看做是对类自身以外的信息进行匹配性校验，通常需要校验下列内容:
        - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
        - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
        - 符号引用中的类、字段、方法的访问性是否可被当前类访问。
        ...
        
        符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethod.Error。
        
- 准备
    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
- 解析
    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
    - 符号引用
        符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
    - 直接引用
        直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

    解析动作包括如下几个:
    1. 类或接口的解析
    2. 字段的解析
    3. 类方法的解析
    4. 接口方法解析
- 初始化
    初始化是类加载过程的最后一步。在准备阶段，变量已经赋过一次系统要求的初始值，而初始化阶段，则根据程序员通过程序制定的主管计划去初始化类变量和其它资源，或者可以从另一个角度表达: 初始化阶段是执行类构造器<clinit>()方法的过程。
        
## 类加载器

对于任意一个类，都需要由加在它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达的更通俗一些:比较两个类是否”相等“，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

### 双亲委派模型

从jvm的角度来讲，只存在两种不同的类加载器: 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器是有C++语言实现，是虚拟机的一部分；另一种就是所有其他的类加载器，这个类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。

绝大部分Java程序都会使用到以下3中系统提供的类加载器:

- 启动类加载器（Bootstrap ClassLoader）:这个类加载器负责将存放在<JAVA_HOME>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直使用null代替即可。
- 扩展类加载器（Extension ClassLoader）:这个加载器有sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接是有扩展类加载器。
- 应用程序类加载器（Application ClassLoader）:这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（classpath）上所指定的类库。可以直接使用，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

双亲委派模型的工作过程: 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子类才会尝试自己去加载。

为什么要用双亲委派机制？
使用双亲委派机制来组织类加载器之间的关系，有个显而易见的好处就是Java类随着它的类加载器一起具备了一中带有优先级的层次关系。例如java.lang.Object，它存放在rt.jar中，无论哪一类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户编写了一个java.lang.Object类，并放在程序的Classpath中，那系统将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。