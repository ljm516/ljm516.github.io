---
title: MySQL索引知识点
date: 2020-01-09 11:43:47
categories: 数据库
tags:
- MySQL
---

MySQL InnoDB存储引擎的索引知识点。

<!--more-->

InnoDB存储引擎支持以下几种常见的索引:
- B+树索引
- 全文索引
- 哈希索引

## B+树索引
在B+树中，所有记录节点都是按键值的大小顺序的放在同一层的叶子节点上，由各叶子节点指针进行连接。
![B+树结构](B+树.png)   
数据库中的B+树索引可以分为聚集索引(clustered index)和辅助索引(secondary index)，其内部都是B+树的，及高度平衡的，叶子节点存放着所有的数据。聚集索引和辅助索引不同的是，叶子节点存放的是否是一整行的信息。

### 聚集索引
聚集索引是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。

聚集索引的一个好处是，它对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。

数据页和非数据页，数据页上存放的是完整的每行数据，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。如果所示:
![](数据页和索引页.png)

### 辅助索引
辅助索引叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签，该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

### 联合索引
联合索引由多个列组成，比如:
```
create table t (
    a int,
    b int,
    primary key (a),
    key idx_a_b (a,b)
)ENGINE=InnoDB;
```
idx_a_b是一个联合索引，联合的列为(a,b)。本质上，联合索引也是一颗B+树，但是键值不是1，而是大于等于2。联合索引所有的数据都是按照(a,b)的顺序存放的，因此对于`select * from t where a=xxx and b=xxx`是可以使用idx_a_b索引的;`select * from t where a=xxx`也是可使用到这个索引。但是对于`select * from t where b=xxx`不能使用该索引（索引的最左原则）。
### 覆盖索引
InnoDB支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是，辅助索引中不包含整行记录，故其大小要远小于聚集索引，因此和以减少大量的IO操作。
辅助索引包含了主键信息，故其叶子节点存的数据为(primary key1, primary key2, key1, key2,...)。那么下面的查询语句都可仅使用一次辅助联合索引来完成:
```
select primary key,primary key2 from t where key1=xxx;
select key1,key2 from t where key1=xxx;
select key2 from t where key1=xxx;
```
覆盖索引还有个好处是对统计问题而言。例如`select count(*) from t`。InnoDB不会通过聚集索引进行统计，因为表t还有辅助索引，而辅助索引的大小远小于聚集索引，选择辅助索引可以减少IO操作。

## 索引失效问题
有时候使用explain命令进行sql分析时，会发现优化器并没有选择索引去查找，而是通过扫描聚集索引，也即是直接进行全表扫描来得到数据。这种情况一般发生在范围查询、JOIN链接操作。下面记录比较常见的导致索引失效问题:

1. where语句中包含or，可能导致索引失效 使用or不一定会使索引失效，需要看or的左右两边的查询列是否命中相同的索引。
即使a列和b列都有索引，下面的语句无法命中索引: select * from t where a = 1 or b=2;

2. where语句中索引列使用了负向查询，可能导致索引失效 负向查询包括: not,!=,<>,!<,!>,not in, not like等。 其实负向查询并不绝对会索引失效，这要看MySQL优化器的判断，全表扫描或者走了索引那个成本更低。

3. 索引字段可以为null，使用is null 或者 is not null时，可能导致索引失效

4. 在索引上使用内置函数，一定会导致索引失效 比如在索引列create_time上使用了函数，索引会失效: select * from t where DATE_ADD(create_time, INTERVAL 1 DAY) = 7; 优化建议，尽量在应用程序中进行计算和转换。

5. 隐式的类型转换导致索引失效 比如下面语句中索引列user_id为varchar类型，不会命中索引: select * from t where user_id=12;

6. 对索引列进行运算，一定会导致索引失效 运算如+,-,*,/等 select * from t where age - 1=10; 优化，将运算放在值上，或者在应用程序中直接算好 select * from t where age = 11;

7. like通配符可能会导致索引失效，解决方法有两种: ①将%移到后面去，如: select * from t where name like '李%'; ②利用覆盖索引来命中索引，如: select * from t where name like '%李%';

8. 联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效 当创建一个联合索引的时候，如(a,b,c)，相当于创建了(a)、(a,b)和(a,b,c)三个索引，这就是最左匹配原则。 比如以下语句都不能命中索引: select * from t where b=1;, select * from t where c=3;, select * from t where b=2 and c=3;

MySQL优化器的最终选择，不走索引上面有提到，即使完全符合索引生效的场景，考虑到实际数据量等原因，最终是否使用索引还要看MySQL优化器的判断。当然你也可以在sql语句中写明强制走某个索引。

**优化索引的一些建议:**

禁止在更新频繁，区分度不高的属性上建立索引
更新会变更B+树，更新频繁的字段建立索引会大大减低数据库性能
区分度不大的属性，建立索引是没有什么意义，不能有效的过滤数据，性能与全表扫描类似
建立组合索引，必须把区分度高的字符

## 其它索引

### 哈希索引
哈希算法提供了O(1)的查询时间复杂度。InnoDB使用哈希算法来对字典进行查询，哈希冲突使用链表法。哈希索引对于字典的查找很快，如:`select * from t where a=xxx`，哈希索引只适用于等值查询，但是对于范围查找就不行了。 

